# A GNU Makefile for Caml Light applications

The accompanying GNU Makefile automates the build of small
Caml Light projects with minimum user input.

The accompanying makefile completely automates the build of small Caml
Light projects with minimum user input and by calling a minimum number
of times the compiler. Great care has been brought to ensure clear and
non-redundant error reporting. Optionally, it may also determine a
default linking order for the object files (see the makefile variable
`OBJ` below). Some classic tools, like `camllex` and `camlyacc`, are
recognised automatically. Command line options specific to a given
tool and a given file can be specified in tag files (metadata).

The makefile has been designed primarily as a development tool, not a
diagnostic tool, so the build process is detailed in a concise and
precise manner, without redundancy, and a great amount of efforts has
been devoted to clear warning and error reporting, in particular the
first error in a causative chain is detailed and the consequent others
are skipped while the compilation goes as far as possible, within
reasonable limits, e.g., if the interface fails to compile, the
implementation is ignored. Uncorrected errors and ignored source files
are reported again.

## Configuration

Make sure the utilities found by running

     $ make conf

are present. The object codes and the executable are generated in a
subdirectory whose name is an underscore followed by the result of the
`arch` shell command, e.g., `"_i686"` (which enables
multi-architecture builds).

It is recommended to use GNU Make 4.0 because the makefile then
leverages the parallel execution feature whilst maintaining
readability.

The minimum configuration in `Makefile.cfg` consists in setting the
variable `BIN` to the basename of the main module. Make sure that the
Perl script `camldep` distributed along this file is found, instead of
the original `camldep` in the Caml Light distribution, upon which it
is based.

Optional variables are the following.

* `OBJ`
  Basenames of the source files containing the byte-codes to be
  linked, ordered as the linker expects them to be. If OBJ is empty or
  undefined, the makefile determines and sorts the objects to be
  linked. Setting this variable increases speed and not doing so may
  lead to unexpected behaviour due to interfering side-effects at
  link-time.

* `VERB`
  You may set this variable to `yes` if you want a more verbose
  output.

* `DEBUG`
  You may set this variable to `yes` if you want to debug the
  makefile (implies `VERB=yes`).

* `SHELL`
  Set this variable to the command shell you use. Our scripts have
  been tested with `dash` and `bash`. We recommend `SHELL := dash` for
  speed.

* `CFLAGS`
  Additional flags for `camlc -c`, applying to all files (none by
  default). Flags specific to a file *mod*`.mli` or *mod*`.ml` are put
  in the corresponding tag file `.`*mod*`.mli.tag` or `.`*mod*`.ml.tag`.

* `LFLAGS`
  Flags for `camllex`, applying to all files (none by
  default). File-specific options are in the tag file
  `.`*mod*`.mll.tag`, without tool prefix.

* `YFLAGS`
  Additional flags for `camlyacc`, applying to all files (none by
  default). File-specific options are in the tag file
  `.`*mod*`.mly.tag`, without tool prefix.

Further settings in `Makefile.cfg` could be, for example, to add your
own `clean::` rules for removing files generated by Caml Light tools
using command-line options set in `Makefile.cfg` (see list above) or
in tag files.

## A session sample

   $ make
   Compiling gen.mli... done (25 lines).
   Compiling lexer.mli... done (42 lines).
   Compiling errors.mli... done (20 lines).
   Compiling ast.mli... done (241 lines).
   Compiling parser.mli... done (25 lines).
   Compiling macros.mli... done (57 lines).
   Compiling topparse.mli... done (22 lines).
   Compiling topparse.ml... done (80 lines).
   Determining object files... done.
   Compiling auxiliar.mli... done (23 lines).
   Compiling lexer.ml... done (331 lines).
   Compiling errors.ml... done (100 lines).
   Compiling macros.ml... done (151 lines).
   Compiling auxiliar.ml... done (69 lines).
   Compiling parser.ml... done (1357 lines).
   Sorting object files... done (6 objects).
   Warning: in case of tricky initialisations, set OBJ.
   Some modules depend on each other's interfaces:
   Circular parser.zi <- macros.zo dependency dropped.
   This is valid but may be a design issue.
   Linking objects as _i686/topparse... done.

## Targets

The default target is `${BIN}`, the main module. Note: To avoid
unexpected feature interactions, always use *one* of the following
phony targets at each invocation of Make:

* `conf`
   To check the installed Caml Light system. See above.

* `warn`
   To print the names of the files containing warnings.

* `clean`
   To delete all the files produced by the Caml Light system and the
   makefile. Add your own `clean::` rules in `Makefile.cfg`.

* `dep`
   To update the compilation dependencies when maximising independent
   compilations. For debugging.

* `lines`
   To display the number of OCaml lines of the project. The first
   column contains the number of non-empty, non-comment lines in
   implementations (`.ml`) only. Number of lines with a single ";;" is
   also printed. Requires `ocamlwc`.

## Tags

Specific command-line options to be passed to Caml Light tools when
processing a given file *mod*`.mli` or *mod*`.ml1 must be written in a
hidden, metadata file whose name is `.`*mod*`.mli.tag`q or
`.`*mod*`.ml.tag`. The name of the tool must be written at the start
of a line, immediately followed by a semi-colon, then the options. For
example, if we want to enable warnings when compiling the unit
*mod*`.ml`, then `.`*mod`.ml.tag` should contain

            camlc: -W

The options for `camllex` must be written in *mod*`.mll.tag`, those
for `camlyacc` in *mod*`.mly.tag`, and those for the linker in
`.`*mod*`.tag`, without any tool name (just the options).

## Limitations

All source files are parsed to extract the compilation dependencies.
Nevertheless, subsequent extractions will be based only on source
changes or creation, so the cost of parsing unused files when building
from a clean slate is likely to be amortised in the long run.

## Build cycle

Let us assume that there is at least a main module, either of the form
*main*`.ml`, *main*`.mll` (lexer) or *main*`.mly` (parser). A build
cycle always starts with `camldep` updating of the compilation
dependencies of all the source files, and this triggers the generation
of lexers by `camllex` and parsers by `camlyacc`, if any. When
starting from a clean slate, this first step is time consuming and may
report syntax errors in files which are not actually needed to build
the executable. Nevertheless, the updating of dependencies is local,
that is, dependencies are updated if, only if the corresponding source
has changed or was created since the last update, so the initial cost
is amortised. To reduce the noise at this stage, useless and/or faulty
modules should perhaps be put in a subdirectory, since the makefile
only considers the current directory when searching for source files.

After updating compilation dependencies, two different continuations
are possible, depending on the variable `OBJ` being defined or not in
the configuration makefile `Makefile.cfg`, which is included by the
makefile.

If set, this variable lists the basenames of the object files in the
order expected by the linker, and this order is used to compile the
implementations (`*.ml`) as well.

If `OBJ` is undefined, *main*`.zo` is updated, and so are the
interfaces it depends on, as well as the implementations without
interfaces they also depend on. Next, the objects to link are
determined, based on the compilation dependencies. In the absence of
any compilation error, the objects are sorted with the tool
`camllorder` and linked into the executable *main*. Note that not
setting `OBJ` incurs a significant time penalty and it should be set
in case of tricky initialisations at link-time (global side-effects).

## Error handling

At each stage of a build cycle, errors may occur, with two kinds of
consequences: an error may require reporting or some compilation may
be predicted to fail because of a dependency on a faulty module. If a
run of the compiler results in an error, the corresponding message is
logged, so it may be redisplayed when a recompilation is later
requested and is bound to fail again, except if a dependency is
transitively erroneous, in which case the message is not redisplayed
and the compilation is simply skipped and the programmer informed of
this fact.

As mentioned earlier, compilation dependencies are determined by
`camldep`, which never reports any errors.

Object codes are linked into the executable only in the absence of any
compile-time error. Here are the metadata (in hidden files) related to
errors:

* `.`*mod*`.mli.err` and `.`*mod*`.ml.err` contain compilation error
   messages about *mod*`.mli` and *mod*`.ml`, respectively;

* `.`*mod*`.mli.ign` and `.`*mod*`.ml.ign` are empty files indicating
  that *mod*`.mli` and *mod*`.ml`, respectively, should be ignored and
  not compiled; (Note that, whilst the presence of a `.*.err` file
  implies the existence of a corresponding `.*.ign` file, the contrary
  does not always hold because a file may be ignored because its
  compilation would be bound to fail due to a transitive dependency on
  a faulty module.)

* `.`*mod*`.mll.err` and `.`*mod*`.mly.err` contain an error message
     from `camllex` about *mod*`.mll` and an error message from
     `camlyacc` about *mod*`.mly`, respectively;

* `.`*mod*`.err` and `.`*mod*`.opt.err` contain error messages from
     the linker (respectively, in bytecode and native code).

Under no circumstances is the programmer to edit these metadata.


## Tags

Specific command-line options to be passed to Caml Light tools when
processing a given file *mod*`.mli` or *mod*`.ml` must be written in a
hidden, metadata file whose name is `.`*mod*`.mli.tag` or
`.`*mod*`.ml.tag`. The name of the tool must be written at the start
of a line, immediately followed by a semicolon, then the
options. Currently, `camlc`, `camllex` and `camlyacc` are recognised.
For example:

    camlc: -W

The options for `camllex` must be written in `.`*mod*`.mll.tag`, those
for `camlyacc` in `.`*mod*`.mly.tag`, and those for the linker in
`.`*mod*`.tag`, without any tool name (just the options as above).


## Deletions

The changes on the source code between two build cycles are of three
kinds: creation, deletion and modification. Deletion often results in
inconsistencies, therefore this makefile detects deletions between
cycles and takes care of metadata and generated sources, so there is
no need to rebuild from a clean slate. Metadata editions are not
assumed, so they must not be modified. Manual modifications, including
deletions, of object files are taken into account, but these should
not happen in general and are best avoided since, for instance, the
deletion of *mod*`.ml` entails the automatic deletion of *mod*`.zo`.

In order to keep track of deletions, the makefile manages a hidden
file named `.src` containing the source filenames during the last
build cycle. The list is sorted, but this is a side-effect of ensuring
the uniqueness of the names in it.

## Compilation dependencies

A run of `camldep` on an interface *mod*`.mli` yields the dependencies
for the object file *mod*`.zi`. From an implementation *mod*`.ml`, the
dependencies of *mod*`.zo`.

# Issues

By default, an object file *foo*`.zo` depends on *bar*`.zi` if
*bar*`.mli` exists, and on *bar*`.zo` when *bar*`.mli` does not
exist. This leads to a problem when an implementation *mod*`.ml`
without an interface, what we call a *standalone module*, is compiled
successfully, and then an interface *mod*`.mli` is created: only the
interface would then be compiled, although the implementation should
be recompiled as well, in order to check for inconsistencies with
respect to the newly created interface. The traditional remedy
consists in recomputing the dependencies for *all* source files, so
their dependencies on *mod*`.zo` are changed into *mod*`.zi`, but this
is slow because it requires a clean slate.

Another issue is that, also by default, `camldep` ignores any
dependency *bar*`.zi` when *bar*`.mli` does not exist: this yields a
problem when a first cycle successfully builds the executable and then
an interface without implementation is deleted: no recompilation is
triggered, whereas the build should fail. This default behaviour of
`camldep` has also an unfortunate consequence when dependencies upon a
lexer generated by `camllex` or a parser generated by `camlyacc` are
needed: these have to be generated, otherwise their absence would
result in no dependency upon them.

# Solutions

To solve the first problem, we *always* have a file *foo*`.zo` depend
on file *foo*`.zi`. This entails a special treatment of what we call
the *virtual interfaces* of the standalone modules, but dependency
recomputations become local, that is, the dependencies of a
compilation unit are remade if, and only if, its source has changed.

To solve the second problem, we modify very slightly `camldep` so it
does not check for the existence of the source file associated to a
dependency, and we perform some postprocessing on the output in
`Makefile`, for example, to remove modules from the standard
library. (We assume that modules do not have the same name as a
standard module.)

The dependencies of an implementation *mod*`.ml` are stored in the
hidden file `.`*mod*`.ml.dep` and that of an interface *mod*`.mli` in
`.`*mod*`.mli.dep`.

# Macros

The macro `mk_dep` is the only one running `camldep`.

If *mod*`.mli` or *mod*`.ml` is not empty, that is, it is not a stub
for lexers or parsers for the purpose of dependency generation, then
we must remove `.`*mod*`.mli.ign` and/or `.`*mod*`.ml.ign` because no
syntax error has been found and we must enable their (re)compilation.

The output of `camldep` is filtered to exclude standard modules and
add the `.zi` extensions.

# Rules

The rules for updating compilations dependencies are only usable when
Make has not restarted and it also has not been called recursively.

Virtual interfaces (of standalone modules) are assigned the same
dependencies as the corresponding (actual) implementation, except for
the last, because it is the virtual interface itself.

A file `.`*mod*`.ml.zod` contains a version of the default compilation
dependencies in `.`*mod*`.ml.dep` modified in order to find a correct
linking order if `OBJ` is undefined (see Build Cycle
above). Basically, it is the same as `.`*mod*`.ml.dep`, except that
all object interfaces `.zi` have been renamed into object
implementations `.zo`, even if these do not exist. (They may exist in
the future because the `.ml` is created, and that dependence on the
`.zo` will become necessary; if they do not exist, they will be
ignored, anyway.)

# Generated lexers and parser (metaprogramming)

A lexer specification *mod*`.mll` is compiled by `camllex`, which
produces an implementation *mod*`.ml`. Error messages are recorded in
the hidden file `.`*mod*`.mll.err`. A parser specification *mod*`.mly`
is translated by `camlyacc` into an interface *mod*`.mli` and an
implementation *mod*`.ml`. Error messages are stored in the hidden
file `.`*mod*`.mly.err`.

If an error file `.`*mod*`.mll.err` or `.`*mod*`.mly.err` is newer
than its specification *mod*`.mll` or *mod*`.mly`, the error message
it contains is reprinted, otherwise the specification is processed
after erasing previous generated lexers and parsers, together with
their associated object codes and metadata. (This ensures consistency
even if the cycle is interrupted.) If no error is detected by
`camllex` or `camlyacc`, any error file `.*.err` is removed (except in
case of a warning being produced). If an error occurred, the message
is displayed and empty lexers or parsers (so-called *stubs*) are
created, together with their associated metadata `.`*mod*`.mli.ign`
and/or `.`*mod*`.ml.ign`. The reason for producing empty lexers and
parsers in case of error is that the compilation of the
implementations needed by the main module implementation (see Build
Cycle above) must not print again those errors: empty compilation
units will then be detected and silently not compiled because they
appear up to date.

Unfortunately, it is not clear how to distinguish errors from
warnings, hence we use regular expressions like `"error[\: ]"`, but
confusion could still ensue if, for instance, a non-terminal or an
Caml Light module is named `"Conflicts"`.

Furthermore, note that the list of source filenames in `.src` is
updated as soon as possible.

The parser implementation *mod*`.ml` depends on its interface
*mod*`.mli`, with no associated recipe, but the interface *mod*`.mli`
depends on the specification *mod*`.mly`. The reason is to ensure that
the macro `mk_par`, making the parsers, is called only once per parser
and because the second stage of a build cycle updates interfaces, it
will trigger parser generation. Of course, it may happen that
*mod*`.ml` is modified or removed after a successful parser
generation, in which case, *mod*`.mli` being up to date, *mod*`.ml`
would not be updated. To avoid this, the actual first step of the
makefile consists in detecting source file deletions and moving the
directory as close as possible to a consistent state, in this case,
the deletion of either the interface or the implementation yields the
deletion of the other, and so is the issue mentioned above avoided:
*mod*`.ml` *and* *mod*`.mli` are always updated simultaneously.

# Compilation

The design principle is that the recipes for compiling are the only
ones in the makefile allowed to write files `.`*mod*`.mli.err` and
`.`*mod*`.ml.err], which contain compilation errors.

The section about compilation must appear *after* the inclusion of the
compilation dependencies `${DEP}`. That variable lists all the
dependency files *mod*`.mli.dep` and *mod*`.ml.dep` for all
*mod*`.mli` and *mod*`.ml` respectively. The dependencies of the
implementations must be listed *before* the interfaces, so the latter
are updated first (default order of GNU Make). This ensures that the
interfaces of the parsers generated by `camlyacc` are updated before
the implementations... which depend on the interfaces. (See above.)

## Macro `compile`

The macro `compile` is common to all kinds of compilation and never
called directly. Its purpose is to run the appropriate Caml Light
compiler, producing either bytecode or native code, log any error in a
file `.`*mod*`.mli.err` or `.`*mod*`.ml.err`, print the message on the
terminal, and similarly for warnings in `.`*mod*`.mli.wrn` and
*mod*`.ml.wrn` files. The only parameter is either `.zi` or `.zo`.

At the start of the macro, any previous warning is erased and, if
compiling an interface, any object code for the corresponding
implementation is erased.

Note that this is the only macro where objects are modified or
deleted: other macros about compilation only process metadata, like
error files. In case of an error, any object from a prior compilation
is deleted and *mod*`.mli` or *mod*`.ml` is marked as to be ignored by
touching `.`*mod*`.mli.ign` or `.`*mod*`.ml.ign`, depending on the
kind of the source.

The macro `ignore` is called when the compilation unit `$<` is not
compiled, either because it was determined that it is still erroneous
or one of its dependencies is erroneous and we want the programmer to
know that `$<` is ignored. That last bit is achieved by touching the
file `.$<.ign`.

## Macro `comp_unit`

The macro `comp_unit` is a wrapper around the macro `compile`, whose
purpose is the compilation of interfaces and implementations. It is
not used for implementations without interfaces (standalone modules).

If the unit is empty or absent, we do nothing, not even call the macro
`ignore`, because an empty file likely means that there is an
erroneous parser specification *mod*`.mly`. (In fact, *mod*`.mli` and
*mod*`.ml` are always generated from *mod*`.mly`, even empty.) We do
not inform the programmer that we ignore erroneous *mod*`.mli` or
*mod*`.ml` when these have been automatically generated because they
are not part of the original source code, therefore should not be
overwritten manually.

The second step consists in using the macro `chk_dep` to avoid useless
compilations, by examining the `.*.ign` and `.*.err` files associated
to the dependencies. We determine and examine the dependencies. First,
we want to know if one of them at least has been ignored (either
because it is erroneous or it depends transitively on an erroneous
unit), in which case the current unit has to be explicitly ignored as
well, that is, a message is displayed and `.$<.ign` is
touched. Second, if the current unit was found to be erroneous during
a previous run of the compiler, we want to know whether one at least
of its dependencies has been successfully compiled *afterwards*. If
so, we need to recompile the unit `$<`; otherwise, the error message
is simply redisplayed. Notice that we determine whether the object
code is expected to be native code or bytecode by passing `${suffix
$@}` to the macro `compile`.

## Macro `comp_stand`

The macro `comp_stand` is a wrapper around `compile` and is tailored
for the compilation of implementations without associated interfaces
(what we call *standalone modules*). It performs some checks in order
to avoid useless compilations, and informs the programmer without
redundancy. The macro is actually called to make *mod*`.zi` targets,
even though the prerequisite is always *mod*`.ml`. That is because
both *mod*`.zi` and *mod*`.zo` are expected to be produced by the
compiler from the same implementation *mod*`.ml`. The consequence is
that `comp_stand` is similar to `comp_unit`, the main difference being
that any error while compiling the implementation will be considered
as an error on the virtual interface, because we want these errors to
be reported as soon as possible, that is, when interfaces are compiled
(see macro `mv_metadata` and the stages of a build cycle). Another
difference between `comp_stand` and `comp_unit` is that the former can
log the basenames of the standalone modules which failed to compile or
were ignored. This log file, named `.std`, is later used by the macro
`prelink` (see section Linking below).

## Rules

The compilation of interfaces is already understood by reading above
the details about macros `comp_unit` and `comp_stand`. The curious
rule at the end

     %.zi : ;

is useful after a successful build followed by the deletion of a
(needed) interface without implementation: this rule will allow to
ignore the problem and trigger the recompilation of a module which
still depends on it, yielding an informative error message instead of
the cryptic

    *** No rule to make target `XXX.zi', needed by `YYY.zi'.  Stop.

The standalone modules require special care, as usual. They already
have been compiled by `comp_stand` in the rule

     %.zi: %.ml

but in unlikely case the `.zo` has been manually erased, it would be
regenerated here (but only if it must not be ignored).

Note: The existence of warnings is reported the first time they are
produced by a compiler, but they need to be explicitly requested after
that by `make warn`.

# Linking

## Case when `OBJ` is undefined

Chronologically, if `OBJ` is undefined, a recursive call is performed,
updating *main*`.zo`, where *main*`.ml`, *main*`.mll` or *main*`.mly`
is the main module or the specification of the main module. Note that
the assignment

    MARK_STAND := yes

means that we want erroneous standalone modules to be recorded in the
hidden file `.std` by the macro `comp_stand`, because we do not want
to require the corresponding objects for linking later on (yielding
again the same error). By the way, this is why `.std` is removed just
before the recursive call.

After returning from the recursive call, the macro `prelink` is
executed. Its purpose is to determine an over-approximation of the
object files to link, based on the compilation dependencies already
computed by `camldep`, as follows. In the dependency graph, the nodes
*mod*`.zo` and *mod*`.zi` are collapsed and loops are
discarded. Afterwards, a topological sort is performed, such that
*main*`.zo` is listed as the last object. (In fact, for technical
reasons, only the basenames of the objects are recorded in the hidden
file `.lnk`.) This is an over-approximation because we consider the
implementation of a module even if we only depend on its interface
(for a type definition). Moreover, some sorts may not be correct in
presence of the following pattern: when *a*`.zo` depends on *b*`.zi`
and *b*`.zo` depends on *a*`.zi`. This mutual dependencies are valid
if the dependencies are both on types, or if *a*`.ml` uses a value of
*b*`.mli` and *b*`.ml` uses a type from *a*`.mli`: in the latter case,
the correct order is *b*`.zo` *a*`.zo`; in the former, *a*`.zo`
*b*`.zo` would also be correct. Therefore, implementation object files
must be sorted according to their dependencies by `camllorder` and
stored in the hidden file `.obj`. Nevertheless, we should keep in mind
that all this is sound only if no interfering side-effect occurs
between top-level constants at link-time, otherwise the semantics of
the program would depend on this order and you must set the variable
`OBJ` to the basenames of the objects in the right order for linking
(see next section).

The updating of the over-approximation is performed by the macro
`update_links` and depends on the compilation dependencies in
`${DEP}`, and the associated recipe consists in calling the macro
`update_links`, which calls recursively Make and forces it to assume
that the implementations are new and that the objects required to
build `${BIN}.zo` are logged in the file `.lnk`, which is controlled
by setting

   LOG_OBJ := yes

The kinds of rules for creating this trace are twofold: two rules for
interfaces and one for implementations. The former are obvious and
simply have `%.zi` depend on the corresponding `%.zo` if it
exists. Note that, in the recursive call to Make in the macro
`update_links`, the redirection of the standard output to /dev/null is
needed to avoid the printing of loops in the dependencies when logging
the `*.zo` into `.lnk`, because we have the rule

    %.zi: %.zo

and we made sure that, from the output of `camldep`, all `%.zo` depend
on their `%.zi`.

When `.std` and `.lnk` have been updated, the objects in the former
file are removed from the latter, because they will not be available
for linking. Afterwards, linking is performed by a recursive call to
Make with the executable as a target and the sorted object codes as
the value of `OBJ`. This brings us to the case when `OBJ` is defined.

## Case when `OBJ` is defined

Linking is forced when a critical deletion has been made (a
non-critical deletion is the deletion of an interface which has an
associated implementation. See `${CDEL}` and the section on
deletions), even if the dependent objects in `${OBJ}` are up to
date. The macro in charge of calling the linker is `link`. The design
principle is that linking is attempted if, and only if, no compilation
error occurred when updating the objects to link, and at least one of
these objects is newer than the last error message from the linker, if
any. (This is similar to the way we use in macro `chk_dep`.) Any error
is recorded in the hidden file `.${notdir $@}.err`. Any stub is
removed as in the previous case, so they will need updating at the
next cycle.

